
import ee
import canada_wide_projections

def test_eeBatchExport(google_drive_folder):
    
    thisFunctionName = "test_eeBatchExport"
    print( "\n########## " + thisFunctionName + "() starts ..." )

    # MODIS PC LST 2000-2022
    # a line-by-line manual conversion of MODIS_LST_ByGeo_singleVals_2placeDate

    #     import ee
    
    #     ee.Initialize()

    # Import CRS from this script
    # See this script for links to source and description
    proj = canada_wide_projections.ESRI_102001

    # Import geography
    gPC_4326 = ee.FeatureCollection("projects/eperez-cloud/assets/gpc_000b21a_e_4326")
    # print("Population centres",gPC_4326)

    # Import water polygons for masking
    # waterPolys = ee.FeatureCollection("projects/eperez-cloud/assets/canVec1MHydroA_intersect_gpc_000b21a_a")
    waterPolys2 = ee.FeatureCollection("projects/eperez-cloud/assets/canVec_merge_to_dissolve_250K_HydroA")
    # print("Water bodies coincident with pop centres", waterPolys2.limit(5))

    # Import LST image collection.
    # https:#developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD11A1
    modis = ee.ImageCollection('MODIS/061/MOD11A1')
    # print("MODIS collection",modis.limit(2))

    # Select day or night LST data band. LST_Day_1km, LST_Night_1km
    MODIS_LST_day   = modis.select(['LST_Day_1km','QC_Day'],     ['LST_1km','QC'])
    MODIS_LST_night = modis.select(['LST_Night_1km','QC_Night'], ['LST_1km','QC'])
    # print("MODIS Day", MODIS_LST_day.limit(1), "MODIS Night", MODIS_LST_night.limit(1))

    # 'switches' ####################################
    timeFrame = 'winter'
    dayOrNight = 'day'
    visibilityGTE = 0.5
    #     exportFolder = 'LST_PC_2000-2022_Hyd250K_QAmsk'
    exportFolder = google_drive_folder
    # 'switches' ####################################

    def _processEveryLocationReturnFeatCol(aPlace, ithFeatCol):
        aPlace = ee.Feature(aPlace)

        years = ee.List.sequence(2000, 2022)
        yearImages = ee.ImageCollection(years.map(_yearsToImages))

        # I want to remove the images that are constants after,
        # so I cast this to an imageCollection. This way I
        # can use the filter greaterThanOrEquals on it.
        # Otherwise EE doesn't know what kind of data yearImages is.
        timePeriodImageCollection = ee.ImageCollection(yearImages
            .iterate(_seasonLST, yearImages)
            ).filter(ee.Filter.greaterThanOrEquals('day', 1))
        # print('timePeriodImageCollection', timePeriodImageCollection)

        seriesOfDates = (timePeriodImageCollection
            .aggregate_array('dateString') )         #.aside(print)
        seriesOfLocationValues = (timePeriodImageCollection
            .iterate(_scoopImageValues, []))          #.aside(print)
        # d = ee.Dictionary.fromLists(seriesOfDates, seriesOfLocationValues) #.aside(print)
        # aPlaceWDateValues = aPlace.set('dateValues', d)

        zipped = seriesOfDates.zip(seriesOfLocationValues).flatten()
        aPlaceWDateValues = aPlace.set(zipped)

        # Need an alternative to .merge() because this will create horrible feature names
        ithFeatCol = ee.FeatureCollection(ithFeatCol).merge(aPlaceWDateValues)


        def _scoopImageValues(image, ithList):
            fracVisible = getCoverageFraction(ee.Feature(aPlace), image)
            image = ee.Image(image)
            image = maskInside(image)    # the water mask
            band0Name = ee.Image(image).bandNames().get(0)
            nominalScale = ee.Image(image).projection().nominalScale()

            trueCase = (ee.Image(image).reduceRegion({
                reducer: ee.Reducer.mean().unweighted(), # spatial mean
                geometry: ee.Feature(aPlace).geometry(),
                crs: proj,
                scale: nominalScale
                }).get(band0Name))
            falseCase = (ee.Image(-99).reduceRegion({
                reducer: ee.Reducer.mean().unweighted(), # spatial mean
                geometry: ee.Feature(aPlace).geometry(),
                crs: proj,
                scale: nominalScale
                }).rename(['constant'], [band0Name]).get(band0Name))
            meanValue = ee.Algorithms.If(fracVisible.gte(visibilityGTE), trueCase, falseCase)

            return ee.List(ithList).cat(ee.List([meanValue]))

        return ithFeatCol


    def _seasonLST(yearImage, ithCollection):
        year = yearImage.get('year')

        if timeFrame == 'winter':
            startDate = ee.Date.fromYMD(year, 1, 1).advance(-1, 'month')
            endDate = ee.Date.fromYMD(year, 3, 31).advance(-1, 'month')
        elif timeFrame == 'spring':
            startDate = ee.Date.fromYMD(year, 3, 1)
            endDate = ee.Date.fromYMD(year, 5, 31)
        elif timeFrame == 'summer':
            startDate = ee.Date.fromYMD(year, 6, 1)
            endDate = ee.Date.fromYMD(year, 8, 31)
        elif timeFrame == 'fall':
            startDate = ee.Date.fromYMD(year, 9, 1)
            endDate = ee.Date.fromYMD(year, 11, 30)
        elif timeFrame == 'winter':
            startDate = ee.Date.fromYMD(year, 1, 1).advance(-1, 'month')
            endDate = ee.Date.fromYMD(year, 11, 30)

        if dayOrNight == 'day':
            modisDayOrNight = MODIS_LST_day
        elif dayOrNight == 'night':
            modisDayOrNight = MODIS_LST_night

        filtered = (ee.ImageCollection(modisDayOrNight)
            .filter(ee.Filter.date(startDate, endDate))
            .map(_reprojectImage)
            .map(_mappableQAfilter)
            .map(_setDateDetails))

        return (ee.ImageCollection(ithCollection)
            .merge(ee.ImageCollection(filtered)))


    def _yearsToImages(i):
        i = ee.Number(i).round()
        return ee.Image(i).set('year', i)


    def getCoverageFraction(popCentre, day):
        # find out what kind of coverage we have
        # inside the PC boundaries on a given day
        popCentre = ee.Feature(popCentre)
        popCentre_area = (popCentre
            .area(1, proj)
            .divide(1000000)) # area of PC in sq kM
        image = (ee.Image(day).select(0)               # just one band from our day's image
            .reproject(proj, null, 1000))              # we'll use Albers Equal Area
        imageClp = image.clip(popCentre)# clip the MODIS image to just this PC
        covered_area = ee.Number(ee.Image(0)
            .clip(popCentre)
            .where(imageClp.select(0),
            ee.Image.pixelArea()
                .clip(popCentre))                         # return the pixel area
            .reduceRegion('sum', popCentre.geometry(), 1000)  # the total area covered by info
            .get('constant')
            ).divide(1000000)
        proportion_covered = (covered_area
            .divide(popCentre_area)
            .multiply(100))
        return ee.Number(proportion_covered)


    def _setDateDetails(modisImage):
        SysIndex = modisImage.get('system:index')
        parsedSI = ee.Date.parse('yyyy_MM_dd', SysIndex)
        modisImage = (ee.Image(modisImage)
            .set('date', parsedSI,
                'year', parsedSI.get('year'),
                'month', parsedSI.get('month'),
                'day', parsedSI.get('day'),
                'dateString', parsedSI.format("yyyy-MM-dd")
                ))
        return modisImage


    def maskInside(image):
        mask = ee.Image.constant(1).clip(waterPolys2).mask().Not()
        return ee.Image(image).updateMask(mask).copyProperties(image)


    def _reprojectImage(image):
        transformed = image.reproject(proj,null,image.projection().nominalScale())
        return ee.Image(transformed).copyProperties(image)


    def _mappableQAfilter(i):
        QA            = i.select('QC')
        baseQuality   = ee.Image(getQABitsIntoSingleBand(QA,0,1,'baseQA'))
        LSTQuality    = ee.Image(getQABitsIntoSingleBand(QA,6,7,'LST_error'))
        baseMask      = baseQuality.neq(2).And(baseQuality.neq(3))
        LSTmask       = LSTQuality.lt(3)
        return i.select('LST_1km').updateMask(baseMask).updateMask(LSTmask)


    def getQABitsIntoSingleBand(QA_band, start_bit, end_bit, new_band_name):
        # a single band (your QA band)
        # start with your lowest bit
        # end with the highest bit
        # returns a band where the cell values are members of the set
        # of possible values for the flag of interest
        pattern = 0
        for i in range(start_bit, end_bit + 1):
            pattern += Math.pow(2, i)
            i += i

        return (QA_band.select([0], [new_band_name])
        .bitwiseAnd(pattern).rightShift(start_bit))


    FinalProduct = gPC_4326.iterate(_processEveryLocationReturnFeatCol, ee.FeatureCollection([]))
    # print('FinalProduct', FinalProduct)

    if timeFrame == 'winter':
        period = '1Winter'
    elif timeFrame == 'spring':
        period = '2Spring'
    elif timeFrame == 'summer':
        period = '3Summer'
    elif timeFrame == 'fall':
        period = '4Fall'
    elif timeFrame == 'annual':
        period = '0Annual'

    visibilityGTE = round(visibilityGTE*10);
    exportString = 'MODIS' + period + dayOrNight + 'LSTbyPC_unweighted_visGTE_' + visibilityGTE + '_wm_qam'

    temp_task = ee.batch.Export.table.toDrive(**{
        "collection": FinalProduct.getInfo(),
        "description": exportString,
        "folder": exportFolder,
        "fileNamePrefix": exportString,
        "fileFormat": 'CSV'})
    temp_task.start()
    return( None )
    
    
    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     my_point = ee.Geometry.Point(13.481643640792527,52.48959983479137);

#     s2 = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \
#         .filterDate(ee.Date('2019-05-01'),ee.Date('2019-08-01')) \
#         .filterBounds(my_point);

#     n_images = s2.size().getInfo();
#     print("\nn_images (s2)");
#     print(   n_images      );

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     my_polygon = ee.Geometry.Polygon([[
#       [82.60642647743225, 27.163504378052510],
#       [82.60984897613525, 27.161852990137700],
#       [82.61088967323303, 27.163695288375266],
#       [82.60757446289062, 27.165174832309270]
#     ]])

#     filtered = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \
#         .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE',30)) \
#         .filter(ee.Filter.date('2019-02-01','2019-03-01')) \
#         .filter(ee.Filter.bounds(my_polygon)) \
#         .map(maskS2clouds)

#     n_images = filtered.size().getInfo()
#     print("\nn_images (filtered)")
#     print(   n_images            )

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     withNdvi = filtered.map(addNDVI)

#     n_images <- withNdvi.size().getInfo();
#     print("\nn_images (withNdvi)");
#     print(  n_images             );

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     ndvi = withNdvi.median().select('ndvi')

#     stats = ndvi.reduceRegion(**{
#       'reducer'  : ee.Reducer.mean(),
#       'geometry' : my_polygon,
#       'scale'    : 10,
#       'maxPixels': 1e10
#       })

#     print("\nstats.getInfo()");
#     print(   stats.getInfo() );

#     print("\nstats.get('ndvi').getInfo()\n")
#     print(   stats.get('ndvi').getInfo()   )

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     image_ids = withNdvi.aggregate_array('system:index').getInfo();

#     print("\nlen(image_ids): ", len(image_ids) )

#     print("\nimage_ids")
#     print(   image_ids )

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     temp_image = ee.Image(withNdvi.filter(ee.Filter.eq('system:index',image_ids[0])).first());
#     temp_info  = temp_image.geometry().bounds().getInfo();

#     print("\ntemp_info");
#     print(   temp_info );

#     for i, image_id in enumerate(image_ids):
#         temp_image = ee.Image(withNdvi.filter(ee.Filter.eq('system:index',image_id)).first());
#         temp_task  = ee.batch.Export.image.toDrive(**{
#             'image'         : temp_image.select('ndvi'),
#             'description'   : 'Image Export {}'.format(i+1),
#             'fileNamePrefix': temp_image.id().getInfo(),
#             'folder'        : google_drive_folder, # 'earthengine/patrick', #folder names with separators (e.g. 'path/to/file') are interpreted as literal strings, not system paths.
#             'scale'         : 100,
#             'region'        : temp_image.geometry().bounds().getInfo()['coordinates'],
#             'maxPixels'     : 1e10
#             })
#         temp_task.start();
#         print("\nStarted task: " + str(image_id) + "\n");

#     ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#     print( "\n########## " + thisFunctionName + "() exits ..." )
#     return( None )

##### ##### ##### ##### #####
# def maskS2clouds(image):
#   qa = image.select('QA60')
#   cloudBitMask  = 1 << 10
#   cirrusBitMask = 1 << 11
#   mask = qa.bitwiseAnd(cloudBitMask).eq(0).And(
#              qa.bitwiseAnd(cirrusBitMask).eq(0))
#   return image.updateMask(mask) \
#       .select("B.*") \
#       .copyProperties(image, ["system:time_start"])

# def addNDVI(image):
#   ndvi = image.normalizedDifference(['B8','B4']).rename('ndvi')
#   return image.addBands(ndvi)
